<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Camera Management - Analyse</title>
    <link rel="stylesheet" href="analysis.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="dashboard-container">
        <header class="dashboard-header">
            <h1>AI Camera Management</h1>
            <div class="user-info">
                <span>Welcome, <span id="userName"></span>!</span>
                <button onclick="logout()" class="logout-btn">Logout</button>
            </div>
        </header>

        <nav class="dashboard-nav">
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="dashboard.html" class="nav-link">Dashboard</a>
                </li>
                <li class="nav-item">
                    <a href="productions.html" class="nav-link">Productions</a>
                </li>
                <li class="nav-item">
                    <a href="equipment.html" class="nav-link">Equipment</a>
                </li>
                <li class="nav-item">
                    <a href="installations.html" class="nav-link">Installations</a>
                </li>
                <li class="nav-item">
                    <a href="finance.html" class="nav-link">Finance</a>
                </li>
                <li class="nav-item">
                    <a href="analysis.html" class="nav-link active">Analyse</a>
                </li>
            </ul>
        </nav>

        <main class="dashboard-content">
                        <h2>Standort Analyse</h2>

            <!-- Haupt-Layout: Sidebar + Content -->
            <div class="analysis-layout">
                <!-- Sidebar mit Filtern -->
                <aside class="analysis-sidebar">
                    <div class="sidebar-header">
                        <h3>Filteroptionen</h3>
                    </div>

                    <div class="sidebar-content">
                        <!-- Region Filter -->
                        <div class="filter-group">
                            <label>Region:</label>
                            <select id="regionFilter" onchange="applyFilters()">
                                <option value="all">Alle Regionen</option>
                                <option value="europe">Europa</option>
                                <option value="usa">USA</option>
                            </select>
                        </div>

                        <!-- Land Filter -->
                        <div class="filter-group">
                            <label>Land:</label>
                            <select id="countryFilter" onchange="applyFilters()">
                                <option value="all">Alle L√§nder</option>
                                <!-- Wird dynamisch gef√ºllt -->
                            </select>
                        </div>

                        <!-- Event Manager Filter -->
                        <div class="filter-group">
                            <label>Event Manager:</label>
                            <select id="eventManagerFilter" onchange="applyFilters()">
                                <option value="all">Alle Manager</option>
                                <!-- Wird dynamisch gef√ºllt -->
                            </select>
                        </div>

                        <!-- Mindestanzahl Events -->
                        <div class="filter-group">
                            <label for="minEvents">Min. Events:</label>
                            <input type="number" id="minEvents" value="1" min="1" onchange="applyFilters()">
                        </div>

                        <!-- Mindestanzahl Tage -->
                        <div class="filter-group">
                            <label for="minDays">Min. Tage:</label>
                            <input type="number" id="minDays" value="1" min="1" onchange="applyFilters()">
                        </div>

                        <!-- Sortierung -->
                        <div class="filter-group">
                            <label for="sortBy">Sortierung:</label>
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="days">Tage (Rentabilit√§t)</option>
                                <option value="events">Events Anzahl</option>
                                <option value="saving">Einsparungen</option>
                                <option value="location">Standort (A-Z)</option>
                            </select>
                        </div>

                        <!-- Filter Buttons -->
                        <div class="filter-buttons">
                            <button class="btn-apply" onclick="applyFilters()">Filter anwenden</button>
                            <button class="btn-reset" onclick="resetFilters()">Filter zur√ºcksetzen</button>
                        </div>

                        <!-- Aktuelle Filter-Anzeige -->
                        <div class="active-filters" id="activeFilters">
                            <!-- Wird dynamisch gef√ºllt -->
                        </div>
                    </div>
                </aside>

                <!-- Hauptinhalt -->
                <div class="analysis-content">
                    <!-- Pagination Info -->
                    <div class="pagination-info" id="paginationInfo" style="display: none;">
                        <span id="pageInfo">Seite 1 von 1</span>
                        <div class="pagination-controls">
                            <button id="prevPage" onclick="changePage(-1)" disabled>‚óÄ Vorherige</button>
                            <button id="nextPage" onclick="changePage(1)">N√§chste ‚ñ∂</button>
                        </div>
                    </div>

                    <!-- Lade-Indikator -->
                    <div id="loadingIndicator" class="loading-indicator" style="display: none;">
                        <p>Analyzing event data...</p>
                    </div>

                    <!-- Analyse-Ergebnisse -->
                    <div id="analysisResults" class="analysis-results" style="display: none;">
                        <div class="analysis-summary">
                            <h3>Standort √úbersicht</h3>
                            <div class="summary-stats">
                                <div class="summary-item">
                                    <span class="summary-label">Standorte gesamt:</span>
                                    <span class="summary-value" id="totalLocations">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Events gesamt:</span>
                                    <span class="summary-value" id="totalEvents">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Produktionstage gesamt:</span>
                                    <span class="summary-value" id="totalDays">-</span>
                                </div>
                                <div class="summary-item">
                                    <span class="summary-label">Potenzielle Jahreseinsparungen:</span>
                                    <span class="summary-value" id="potentialSavings">-</span>
                                </div>
                            </div>
                        </div>

                        <div class="analysis-table-container">
                            <table class="analysis-table" id="locationAnalysisTable">
                                <thead>
                                    <tr>
                                        <th>Standort</th>
                                        <th>Land</th>
                                        <th>Gesamt Tage</th>
                                        <th>üé¨ Kameramann</th>
                                        <th>ü§ñ KI-Systeme</th>
                                    </tr>
                                </thead>
                                <tbody id="locationAnalysisBody">
                                    <!-- Dynamisch geladen -->
                                </tbody>
                            </table>
                        </div>

                        <!-- Pagination Controls -->
                        <div class="pagination-controls">
                            <div class="pagination-info">
                                <span id="paginationInfo">Zeige 1-25 von 233 Standorten</span>
                            </div>
                            <div class="pagination-buttons">
                                <button id="prevPage" onclick="goToPage(currentPage - 1)" disabled>
                                    ‚óÄ Vorherige
                                </button>
                                <span id="pageNumbers">
                                    <!-- Seiten-Buttons werden dynamisch generiert -->
                                </span>
                                <button id="nextPage" onclick="goToPage(currentPage + 1)">
                                    N√§chste ‚ñ∂
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


        </main>

        <!-- Speicher-Info Modal -->
        <div id="storageInfoModal" class="modal">
            <div class="modal-content storage-modal">
                <div class="modal-header">
                    <h3>üíæ Gespeicherte √Ñnderungen</h3>
                    <span class="modal-close" onclick="closeStorageInfoModal()">&times;</span>
                </div>
                <div class="modal-body">
                    <div class="storage-info-content">
                        <p>Ihre Event-√Ñnderungen wurden im Browser-Speicher gesichert.</p>
                        <p><strong>Um die √Ñnderungen dauerhaft zu speichern:</strong></p>
                        <ol>
                            <li>√ñffnen Sie die Browser-Konsole (F12)</li>
                            <li>Geben Sie ein: <code>exportEditedEvents()</code></li>
                            <li>Kopieren Sie die ausgegebene JSON-Daten</li>
                            <li>F√ºgen Sie diese in die <code>events.json</code> Datei ein</li>
                        </ol>

                        <div class="storage-actions">
                            <button onclick="console.log('Konsole-Tip: exportEditedEvents()'); closeStorageInfoModal();" class="btn-primary">
                                üìÑ JSON Export starten
                            </button>
                            <button onclick="clearEditedEvents()" class="btn-danger">
                                üóëÔ∏è Alle √Ñnderungen verwerfen
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Info Modal -->
    <div id="downloadInfoModal" class="modal">
        <div class="modal-content download-modal">
            <div class="modal-header">
                <h3>üì• JSON-Datei heruntergeladen</h3>
                <span class="modal-close" onclick="closeDownloadInfoModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="download-info-content">
                    <p><strong>Die ge√§nderte events.json wurde heruntergeladen!</strong></p>
                    <p>Um die √Ñnderungen dauerhaft zu speichern:</p>
                    <ol>
                        <li>√ñffnen Sie den Download-Ordner Ihres Browsers</li>
                        <li>Suchen Sie die Datei <code>events_updated.json</code></li>
                        <li>Kopieren Sie diese Datei in Ihren Projektordner</li>
                        <li>Benennen Sie die alte <code>events.json</code> um (z.B. events_backup.json)</li>
                        <li>Benennen Sie <code>events_updated.json</code> in <code>events.json</code> um</li>
                    </ol>

                    <div class="download-actions">
                        <button onclick="closeDownloadInfoModal()" class="btn-primary">
                            ‚úÖ Verstanden
                        </button>
                        <button onclick="location.reload()" class="btn-secondary">
                            üîÑ Seite neu laden
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal f√ºr Veranstaltung bearbeiten -->
    <div id="editEventModal" class="modal">
        <div class="modal-content edit-event-modal">
            <div class="modal-header">
                <h3>Veranstaltung bearbeiten</h3>
                <span class="modal-close" onclick="closeEditEventModal()">&times;</span>
            </div>
            <div class="modal-body">
                <form id="editEventForm">
                    <input type="hidden" id="editEventLocationIndex">
                    <input type="hidden" id="editEventIndex">

                    <div class="form-row">
                        <div class="form-group">
                            <label for="editEventName">Veranstaltungsname *</label>
                            <input type="text" id="editEventName" name="editEventName" required>
                        </div>
                        <div class="form-group">
                            <label for="editEventStartDate">Startdatum *</label>
                            <input type="date" id="editEventStartDate" name="editEventStartDate" required>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="editEventEndDate">Enddatum *</label>
                            <input type="date" id="editEventEndDate" name="editEventEndDate" required>
                        </div>
                        <div class="form-group">
                            <label for="editEventDiscipline">Disziplin</label>
                            <input type="text" id="editEventDiscipline" name="editEventDiscipline">
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="editEventManager">Event Manager</label>
                            <input type="text" id="editEventManager" name="editEventManager">
                        </div>
                        <div class="form-group">
                            <label for="editEventKiSuitable">KI-geeignet</label>
                            <div class="checkbox-container">
                                <input type="checkbox" id="editEventKiSuitable" name="editEventKiSuitable">
                                <label for="editEventKiSuitable" class="checkbox-label">
                                    Diese Veranstaltung eignet sich f√ºr KI-Aufzeichnung
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label for="editEventNotes">Notizen</label>
                            <textarea id="editEventNotes" name="editEventNotes" rows="3" placeholder="Zus√§tzliche Notizen zur Veranstaltung..."></textarea>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-danger" onclick="deleteEvent()">Veranstaltung l√∂schen</button>
                <button type="button" class="btn-secondary" onclick="closeEditEventModal()">Abbrechen</button>
                <button type="button" class="btn-primary" onclick="saveEditedEvent()">Speichern</button>
            </div>
        </div>
    </div>

    <script>
        // Check if user is logged in
        const currentUser = localStorage.getItem('currentUser');
        if (!currentUser) {
            window.location.href = 'index.html';
        } else {
            document.getElementById('userName').textContent = JSON.parse(currentUser).fullName;
        }

        function logout() {
            localStorage.removeItem('currentUser');
            window.location.href = 'index.html';
        }

        // Globale Variablen
        let eventsData = [];
        let analysisResults = [];
        let filteredResults = [];
        let currentPage = 1;
        const itemsPerPage = 25;
        let currentEditingLocationIndex = null;
        let currentEditingEventIndex = null;

        // Kosten-Konstanten
        const COSTS = {
            operator: {
                europe: 400, // ‚Ç¨ pro Tag
                usa: 250      // ‚Ç¨ pro Tag
            },
            systems: {
                k2: 6100,     // ‚Ç¨ Gesamtsystem (4 Jahre)
                n6: 15500,    // ‚Ç¨ Gesamtsystem (4 Jahre)
                n8: 24500     // ‚Ç¨ Gesamtsystem (4 Jahre)
            },
            // Annahme: gleiche j√§hrliche Auslastung wie aktuelles Jahr
            annualDaysAssumption: 365  // Tage pro Jahr f√ºr Durchschnittsberechnung
        };

        // Event-Daten laden und analysieren
        async function loadAndAnalyzeEvents() {
            try {
                document.getElementById('loadingIndicator').style.display = 'block';
                document.getElementById('analysisResults').style.display = 'none';


                console.log('üìä Loading events data for analysis...');

                // Events JSON laden
                const response = await fetch('events.json');
                const data = await response.json();
                let originalEvents = data.events || [];

                // Gespeicherte Events laden und mergen
                const savedEvents = loadEventsFromLocalStorage();
                if (savedEvents && savedEvents.length > 0) {
                    console.log('üîÑ Merge gespeicherte Events mit Original-Daten...');

                    // Erstelle eine Map der gespeicherten Events f√ºr schnellen Zugriff
                    const savedEventsMap = new Map();
                    savedEvents.forEach(event => {
                        savedEventsMap.set(event.id, event);
                    });

                    // Merge: √úberschreibe Original-Events mit gespeicherten Daten
                    originalEvents = originalEvents.map(originalEvent => {
                        const savedEvent = savedEventsMap.get(originalEvent.id);
                        if (savedEvent) {
                            console.log('üìù Event aktualisiert:', originalEvent.name);
                            return { ...originalEvent, ...savedEvent };
                        }
                        return originalEvent;
                    });

                    console.log('‚úÖ Events erfolgreich gemerged');
                }

                eventsData = originalEvents;

                console.log(`üìä Loaded ${eventsData.length} events for analysis`);
                console.log('Sample event:', eventsData[0]);

                // Daten analysieren
                await analyzeLocations();

            } catch (error) {
                console.error('Fehler beim Laden der Event-Daten:', error);
                document.getElementById('loadingIndicator').innerHTML = '<p class="error">Error loading event data</p>';
            }
        }

        // Standort-Analyse durchf√ºhren
        async function analyzeLocations() {
            console.log('üîç Analyzing locations...');

            // Events nach Standort gruppieren
            const locationGroups = {};

            eventsData.forEach(event => {
                const location = event.location || 'Unknown';
                const country = event.country || 'Unknown';

                if (!locationGroups[location]) {
                    locationGroups[location] = {
                        location: location,
                        country: country,
                        events: [],
                        totalDays: 0,
                        region: getRegion(country)
                    };
                }

                // Event kopieren um es zu erweitern
                const eventWithDays = {
                    ...event,
                    days: calculateEventDays(event.start_date, event.end_date),
                    kiSuitable: event.kiSuitable || false  // KI-Suitability Flag
                };

                locationGroups[location].events.push(eventWithDays);
                locationGroups[location].totalDays += eventWithDays.days;
            });

            console.log(`üîç Found ${Object.keys(locationGroups).length} unique locations`);

            // Debug: Erstes paar Locations zeigen
            const locationKeys = Object.keys(locationGroups);
            if (locationKeys.length > 0) {
                console.log('Sample location data:', locationGroups[locationKeys[0]]);
            }

            // Kostenanalyse f√ºr jeden Standort
            analysisResults = Object.values(locationGroups).map(location => {
                return analyzeLocationCosts(location);
            });

            // Nach KI-Suitability und Produktionstagen sortieren
            analysisResults.sort((a, b) => {
                // Zuerst pr√ºfen, ob einer der Standorte KI-geeignete Veranstaltungen hat
                const aHasKiSuitable = a.events.some(event => event.kiSuitable);
                const bHasKiSuitable = b.events.some(event => event.kiSuitable);

                if (aHasKiSuitable && !bHasKiSuitable) return -1; // a zuerst
                if (!aHasKiSuitable && bHasKiSuitable) return 1;  // b zuerst

                // Bei gleichem KI-Status nach Produktionstagen sortieren
                return b.totalDays - a.totalDays;
            });

            // Dynamische Tageskosten basierend auf Gesamtauslastung berechnen
            updateDynamicCosts();

            // Filter-Dropdowns f√ºllen
            populateFilterDropdowns();

            // Gefilterte Ergebnisse initial setzen
            filteredResults = [...analysisResults];
            currentPage = 1;

            // Ergebnisse anzeigen
            displayAnalysisResults();


            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('analysisResults').style.display = 'block';

        }

        // Region basierend auf Land bestimmen
        function getRegion(country) {
            const europeCountries = ['DE', 'FR', 'GB', 'IT', 'ES', 'NL', 'BE', 'AT', 'CH', 'SE', 'NO', 'DK', 'FI', 'PL', 'CZ', 'HU', 'SK', 'SI', 'HR', 'BG', 'RO', 'EE', 'LV', 'LT'];
            const usaCountries = ['US', 'USA'];

            if (europeCountries.includes(country)) return 'europe';
            if (usaCountries.includes(country)) return 'usa';
            return 'other';
        }

        // Event-Tage berechnen
        function calculateEventDays(startDate, endDate) {
            try {
                // Deutsche Datumsformate parsen (DD.MM.YYYY)
                const start = parseGermanDate(startDate);
                const end = parseGermanDate(endDate);

                if (!start || !end) return 1; // Fallback

                const diffTime = Math.abs(end - start);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 f√ºr inklusiven Endtag

                return Math.max(1, diffDays); // Mindestens 1 Tag
            } catch (error) {
                console.warn(`Fehler beim Parsen der Daten: ${startDate} - ${endDate}`, error);
                return 1;
            }
        }

        // Deutsche Datumsformate parsen
        function parseGermanDate(dateString) {
            if (!dateString) return null;

            // Format: DD.MM.YYYY
            const parts = dateString.split('.');
            if (parts.length === 3) {
                const day = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1; // JS Monate sind 0-basiert
                const year = parseInt(parts[2]);
                return new Date(year, month, day);
            }

            // Fallback: Versuche andere Formate
            return new Date(dateString);
        }

        // Kostenanalyse f√ºr einen Standort
        function analyzeLocationCosts(location) {
            const region = location.region;
            const operatorCostPerDay = COSTS.operator[region] || COSTS.operator.europe;
            const totalOperatorCost = location.totalDays * operatorCostPerDay;

            // Annahme: gleiche j√§hrliche Auslastung wie aktuelles Jahr
            const annualProductionDays = location.totalDays;
            const annualOperatorCost = annualProductionDays * operatorCostPerDay;

            // F√ºr jedes System die tats√§chlichen Tageskosten berechnen
            const systems = [
                {
                    name: 'K2',
                    totalCost: COSTS.systems.k2,
                    dailyCost: COSTS.systems.k2 / (annualProductionDays * 4), // Tageskosten √ºber 4 Jahre
                    description: 'K2 Camera System'
                },
                {
                    name: 'N6',
                    totalCost: COSTS.systems.n6,
                    dailyCost: COSTS.systems.n6 / (annualProductionDays * 4), // Tageskosten √ºber 4 Jahre
                    description: 'N6 Camera System'
                },
                {
                    name: 'N8',
                    totalCost: COSTS.systems.n8,
                    dailyCost: COSTS.systems.n8 / (annualProductionDays * 4), // Tageskosten √ºber 4 Jahre
                    description: 'N8 Camera System'
                }
            ];

            // Beste Empfehlung finden (basierend auf t√§glichen Einsparungen)
            let bestSystem = null;
            let maxDailySavings = 0;
            let roiPeriod = 999;

            systems.forEach(system => {
                const dailySavings = operatorCostPerDay - system.dailyCost;

                if (dailySavings > maxDailySavings) {
                    maxDailySavings = dailySavings;
                    bestSystem = system;
                    // ROI in Jahren: Gesamtkosten / j√§hrliche Einsparungen
                    const annualSavings = dailySavings * annualProductionDays;
                    roiPeriod = system.totalCost / Math.max(0.01, annualSavings);
                }
            });



            return {
                ...location,
                operatorCostPerDay: operatorCostPerDay,
                totalOperatorCost: totalOperatorCost,
                annualOperatorCost: annualOperatorCost,
                annualProductionDays: annualProductionDays,
                bestSystem: bestSystem,
                maxDailySavings: maxDailySavings,
                maxAnnualSavings: maxDailySavings * annualProductionDays,
                roiPeriod: roiPeriod,
                systems: systems.map(system => {
                    const dailySavings = operatorCostPerDay - system.dailyCost;
                    const annualSavings = dailySavings * annualProductionDays;
                    return {
                        ...system,
                        dailySavings: dailySavings,
                        annualSavings: annualSavings,
                        roiPeriod: system.totalCost / Math.max(0.01, annualSavings)
                    };
                })
            };
        }

        // Dynamische Tageskosten aktualisieren (falls Elemente vorhanden sind)
        function updateDynamicCosts() {
            // Diese Funktion ist nicht mehr notwendig, da die Kosten-√úbersicht entfernt wurde
            // Aber sicherstellen, dass keine Fehler auftreten, falls Elemente noch referenziert werden

            const k2Element = document.getElementById('k2-daily-cost');
            const n6Element = document.getElementById('n6-daily-cost');
            const n8Element = document.getElementById('n8-daily-cost');

            // Nur aktualisieren, wenn die Elemente tats√§chlich existieren
            if (k2Element || n6Element || n8Element) {
                const totalAnnualDays = analysisResults.reduce((sum, loc) => sum + loc.annualProductionDays, 0);

                if (totalAnnualDays > 0) {
                    const k2DailyCost = COSTS.systems.k2 / (totalAnnualDays * 4);
                    const n6DailyCost = COSTS.systems.n6 / (totalAnnualDays * 4);
                    const n8DailyCost = COSTS.systems.n8 / (totalAnnualDays * 4);

                    if (k2Element) k2Element.textContent = `‚Ç¨${k2DailyCost.toFixed(0)}/Tag`;
                    if (n6Element) n6Element.textContent = `‚Ç¨${n6DailyCost.toFixed(0)}/Tag`;
                    if (n8Element) n8Element.textContent = `‚Ç¨${n8DailyCost.toFixed(0)}/Tag`;
                }
            }

            console.log('üí∞ Dynamic costs calculation completed - elements updated if present');
        }

        // Analyse-Ergebnisse anzeigen mit Pagination
        function displayAnalysisResults() {
            const tbody = document.getElementById('locationAnalysisBody');
            tbody.innerHTML = '';

            // Summary aktualisieren
            const totalLocations = filteredResults.length;
            const totalEvents = filteredResults.reduce((sum, loc) => sum + loc.events.length, 0);
            const totalDays = filteredResults.reduce((sum, loc) => sum + loc.totalDays, 0);
            const potentialSavings = filteredResults.reduce((sum, loc) => sum + (loc.maxAnnualSavings || 0), 0);

            document.getElementById('totalLocations').textContent = totalLocations;
            document.getElementById('totalEvents').textContent = totalEvents;
            document.getElementById('totalDays').textContent = totalDays;
            document.getElementById('potentialSavings').textContent = formatCurrency(potentialSavings);

            // Pagination berechnen
            const totalPages = Math.ceil(filteredResults.length / itemsPerPage);
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredResults.length);
            const currentPageData = filteredResults.slice(startIndex, endIndex);

            // Pagination Info aktualisieren
            const startItem = startIndex + 1;
            const endItem = endIndex;
            document.getElementById('paginationInfo').textContent = `Zeige ${startItem}-${endItem} von ${filteredResults.length} Standorten`;

            // Vor-/Zur√ºck-Buttons aktivieren/deaktivieren
            document.getElementById('prevPage').disabled = currentPage <= 1;
            document.getElementById('nextPage').disabled = currentPage >= totalPages;

            // Seiten-Buttons generieren
            generatePageNumbers(totalPages);

            currentPageData.forEach((location, pageIndex) => {
                const globalIndex = startIndex + pageIndex;
                const row = tbody.insertRow();
                row.className = 'location-row';

                // Events f√ºr diesen Standort sortieren: KI-geeignete zuerst, dann nach Datum
                const sortedEvents = location.events.sort((a, b) => {
                    // KI-geeignete Veranstaltungen haben Priorit√§t
                    if (a.kiSuitable && !b.kiSuitable) return -1;
                    if (!a.kiSuitable && b.kiSuitable) return 1;

                    // Bei gleichem KI-Status nach Datum sortieren
                    const dateA = parseGermanDate(a.start_date);
                    const dateB = parseGermanDate(b.start_date);
                    return dateA - dateB;
                });

                // Kameramann Gesamtkosten f√ºr alle Events
                const totalOperatorCost = location.totalDays * location.operatorCostPerDay;

                // KI-System Kosten pro Tag
                const n6DailyCost = COSTS.systems.n6 / (location.annualProductionDays * 4);
                const n8DailyCost = COSTS.systems.n8 / (location.annualProductionDays * 4);

                row.innerHTML = `
                    <td><strong>${location.location}</strong></td>
                    <td>${location.country}</td>
                    <td><strong>${location.totalDays} Tage</strong></td>
                    <td class="operator-cost">${formatCurrency(totalOperatorCost)}</td>
                    <td>
                        <div class="system-costs">
                            <div class="system-cost k2-item disabled">
                                <strong>K2:</strong> ‚Ç¨${(COSTS.systems.k2 / (location.annualProductionDays * 4)).toFixed(0)}/Tag
                            </div>
                            <div class="system-cost n6-item">
                                <strong>N6:</strong> ‚Ç¨${n6DailyCost.toFixed(0)}/Tag
                            </div>
                            <div class="system-cost n8-item">
                                <strong>N8:</strong> ‚Ç¨${n8DailyCost.toFixed(0)}/Tag
                            </div>
                        </div>
                    </td>
                `;

                // Zweite Zeile f√ºr Veranstaltungen (volle Breite)
                const eventsRow = tbody.insertRow();
                eventsRow.innerHTML = `
                    <td colspan="5" class="events-row">
                        <div class="events-cell-fullwidth">
                            <div class="event-summary" onclick="toggleEvents(${globalIndex})">
                                <span class="event-count">${location.events.length} Veranstaltungen</span>
                                <span class="toggle-icon">‚ñº</span>
                            </div>
                            <div class="event-details" id="events-${globalIndex}" style="display: none;">
                                <div class="events-grid">
                                    ${sortedEvents.map(event => {
                                        const startDate = parseGermanDate(event.start_date);
                                        const endDate = parseGermanDate(event.end_date);
                                        const eventDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
                                        return `
                                            <div class="event-item">
                                                <div class="event-header">
                                                    <div class="event-name"><strong>${event.name}</strong></div>
                                                    <button class="edit-event-btn" onclick="openEditEventModal(${globalIndex}, ${pageIndex})" title="Veranstaltung bearbeiten">
                                                        ‚úèÔ∏è Edit
                                                    </button>
                                                </div>
                                                <div class="event-dates">${formatDateRange(startDate, endDate)}</div>
                                                <div class="event-days">${eventDays} Tage</div>
                                                <div class="event-ki-status">
                                                    ${event.kiSuitable ? '<span class="ki-badge ki-suitable">ü§ñ KI-geeignet</span>' : '<span class="ki-badge ki-not-suitable">‚ùå Nicht KI-geeignet</span>'}
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    </td>
                `;
            });
        }

        // Pagination-Funktionen
        function goToPage(page) {
            const totalPages = Math.ceil(filteredResults.length / itemsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                displayAnalysisResults();
            }
        }

        function generatePageNumbers(totalPages) {
            const pageNumbersContainer = document.getElementById('pageNumbers');
            pageNumbersContainer.innerHTML = '';

            // Berechne Seitenbereich anzuzeigen (max 5 Seiten um die aktuelle Seite)
            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, currentPage + 2);

            // Anpassen wenn wir am Anfang oder Ende sind
            if (endPage - startPage < 4) {
                if (startPage === 1) {
                    endPage = Math.min(totalPages, startPage + 4);
                } else if (endPage === totalPages) {
                    startPage = Math.max(1, endPage - 4);
                }
            }

            // Erste Seite Button (falls nicht im Bereich)
            if (startPage > 1) {
                const firstButton = document.createElement('button');
                firstButton.textContent = '1';
                firstButton.className = currentPage === 1 ? 'page-btn active' : 'page-btn';
                firstButton.onclick = () => goToPage(1);
                pageNumbersContainer.appendChild(firstButton);

                if (startPage > 2) {
                    const dots = document.createElement('span');
                    dots.textContent = '...';
                    dots.className = 'page-dots';
                    pageNumbersContainer.appendChild(dots);
                }
            }

            // Seiten-Buttons im Bereich
            for (let i = startPage; i <= endPage; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.className = currentPage === i ? 'page-btn active' : 'page-btn';
                button.onclick = () => goToPage(i);
                pageNumbersContainer.appendChild(button);
            }

            // Letzte Seite Button (falls nicht im Bereich)
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const dots = document.createElement('span');
                    dots.textContent = '...';
                    dots.className = 'page-dots';
                    pageNumbersContainer.appendChild(dots);
                }

                const lastButton = document.createElement('button');
                lastButton.textContent = totalPages;
                lastButton.className = currentPage === totalPages ? 'page-btn active' : 'page-btn';
                lastButton.onclick = () => goToPage(totalPages);
                pageNumbersContainer.appendChild(lastButton);
            }
        }

        // Empfehlungs-Text generieren


        // W√§hrung formatieren
        function formatCurrency(amount) {
            return new Intl.NumberFormat('de-DE', {
                style: 'currency',
                currency: 'EUR'
            }).format(amount);
        }

        // Datumsbereich formatieren
        function formatDateRange(startDate, endDate) {
            if (!startDate || !endDate) return 'Datum unbekannt';

            try {
                const start = startDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit'
                });
                const end = endDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit'
                });

                if (start === end) {
                    return start; // Ein-Tag Event
                } else {
                    return `${start} - ${end}`;
                }
            } catch (error) {
                console.warn('Fehler beim Formatieren des Datumsbereichs:', error);
                return 'Datum-Fehler';
            }
        }






        // Filter anwenden
        function applyFilters() {
            const regionFilter = document.getElementById('regionFilter').value;
            const minEvents = parseInt(document.getElementById('minEvents').value) || 1;
            const sortBy = document.getElementById('sortBy').value;

            let filtered = analysisResults.filter(location => {
                // Region-Filter
                if (regionFilter !== 'all' && location.region !== regionFilter) {
                    return false;
                }

                // Min Events-Filter
                if (location.events < minEvents) {
                    return false;
                }

                return true;
            });

            // Sortierung
            filtered.sort((a, b) => {
                switch (sortBy) {
                    case 'events':
                        return b.events - a.events;
                    case 'days':
                        return b.totalDays - a.totalDays; // Rentabilit√§t
                    case 'saving':
                        return b.maxDailySavings - a.maxDailySavings; // T√§gliche Einsparungen
                    default:
                        return b.totalDays - a.totalDays; // Standard: nach Tagen
                }
            });

            // Gefilterte Ergebnisse setzen und zur ersten Seite gehen
            filteredResults = filtered;
            currentPage = 1;

            // Gefilterte Ergebnisse anzeigen
            displayAnalysisResults();
        }

        // Events ein-/ausklappen
        function toggleEvents(index) {
            const detailsDiv = document.getElementById(`events-${index}`);
            const toggleIcon = detailsDiv.previousElementSibling.querySelector('.toggle-icon');

            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                toggleIcon.textContent = '‚ñ≤';
            } else {
                detailsDiv.style.display = 'none';
                toggleIcon.textContent = '‚ñº';
            }
        }

        // Gefilterte Ergebnisse anzeigen
        function displayFilteredResults(filtered) {
            const tbody = document.getElementById('locationAnalysisBody');
            tbody.innerHTML = '';

            // Berechne die Indizes f√ºr die aktuelle Seite
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageItems = filtered.slice(startIndex, endIndex);

            pageItems.forEach((location, arrayIndex) => {
                const row = tbody.insertRow();
                row.className = 'location-row';

                // Verwende den globalen Index f√ºr die Event-IDs
                const globalIndex = startIndex + arrayIndex;

                const recommendation = getRecommendationText(location);
                const priorityClass = `priority-${location.priority}`;

                // Events f√ºr diesen Standort sortieren: KI-geeignete zuerst, dann nach Datum
                const sortedEvents = location.events.sort((a, b) => {
                    // KI-geeignete Veranstaltungen haben Priorit√§t
                    if (a.kiSuitable && !b.kiSuitable) return -1;
                    if (!a.kiSuitable && b.kiSuitable) return 1;

                    // Bei gleichem KI-Status nach Datum sortieren
                    const dateA = parseGermanDate(a.start_date);
                    const dateB = parseGermanDate(b.start_date);
                    return dateA - dateB;
                });

                // Kameramann Gesamtkosten f√ºr alle Events
                const totalOperatorCost = location.totalDays * location.operatorCostPerDay;

                // KI-System Kosten pro Tag
                const n6DailyCost = COSTS.systems.n6 / (location.annualProductionDays * 4);
                const n8DailyCost = COSTS.systems.n8 / (location.annualProductionDays * 4);

                row.innerHTML = `
                    <td><strong>${location.location}</strong></td>
                    <td>${location.country}</td>
                    <td>
                        <div class="events-cell">
                            <div class="event-summary" onclick="toggleEvents(${globalIndex})">
                                <span class="event-count">${location.events.length} Events</span>
                                <span class="toggle-icon">‚ñº</span>
                            </div>
                            <div class="event-details" id="events-${globalIndex}" style="display: none;">
                                ${sortedEvents.map(event => {
                                    const startDate = parseGermanDate(event.start_date);
                                    const endDate = parseGermanDate(event.end_date);
                                    return `
                                        <div class="event-item">
                                            <strong>${event.name}</strong><br>
                                            <small>${formatDateRange(startDate, endDate)} (${event.days} Tage)</small>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </td>
                    <td><strong>${location.totalDays} Tage</strong></td>
                    <td class="operator-cost">
                        <div class="cost-display">
                            <div class="cost-icon">üé¨</div>
                            <div class="cost-details">
                                <div class="cost-name">Kameramann</div>
                                <div class="cost-value">${formatCurrency(totalOperatorCost)}</div>
                                <div class="cost-daily">${formatCurrency(location.operatorCostPerDay)}/Tag</div>
                            </div>
                        </div>
                    </td>
                    <td class="systems-cost">
                        <div class="systems-grid">
                            <div class="system-item k2-item">
                                <img src="https://via.placeholder.com/40x40/666666/ffffff?text=K2" alt="K2 Camera" class="system-icon">
                                <div class="system-info">
                                    <div class="system-name">K2</div>
                                    <div class="system-cost">‚Ç¨${(COSTS.systems.k2 / (location.annualProductionDays * 4)).toFixed(0)}/Tag</div>
                                </div>
                            </div>
                            <div class="system-item n6-item">
                                <img src="https://via.placeholder.com/40x40/FF9800/ffffff?text=N6" alt="N6 Camera" class="system-icon">
                                <div class="system-info">
                                    <div class="system-name">N6</div>
                                    <div class="system-cost">‚Ç¨${n6DailyCost.toFixed(0)}/Tag</div>
                                </div>
                            </div>
                            <div class="system-item n8-item">
                                <img src="https://via.placeholder.com/40x40/9C27B0/ffffff?text=N8" alt="N8 Camera" class="system-icon">
                                <div class="system-info">
                                    <div class="system-name">N8</div>
                                    <div class="system-cost">‚Ç¨${n8DailyCost.toFixed(0)}/Tag</div>
                                </div>
                            </div>
                        </div>
                    </td>
                `;
            });

            // Summary f√ºr gefilterte Ergebnisse aktualisieren
            const totalLocations = filtered.length;
            const totalEvents = filtered.reduce((sum, loc) => sum + loc.events.length, 0);
            const totalDays = filtered.reduce((sum, loc) => sum + loc.totalDays, 0);
            const potentialSavings = filtered.reduce((sum, loc) => sum + (loc.maxAnnualSavings || 0), 0);

            document.getElementById('totalLocations').textContent = totalLocations;
            document.getElementById('totalEvents').textContent = totalEvents;
            document.getElementById('totalDays').textContent = totalDays;
            document.getElementById('potentialSavings').textContent = formatCurrency(potentialSavings);
        }

        // Filter-Dropdowns f√ºllen
        function populateFilterDropdowns() {
            // L√§nder sammeln
            const countries = new Set();
            const eventManagers = new Set();

            analysisResults.forEach(location => {
                countries.add(location.country);
                // Event Manager aus den Events sammeln
                location.events.forEach(event => {
                    if (event.event_manager) {
                        eventManagers.add(event.event_manager);
                    }
                });
            });

            // L√§nder-Dropdown f√ºllen
            const countrySelect = document.getElementById('countryFilter');
            Array.from(countries).sort().forEach(country => {
                const option = document.createElement('option');
                option.value = country;
                option.textContent = country;
                countrySelect.appendChild(option);
            });

            // Event Manager-Dropdown f√ºllen
            const managerSelect = document.getElementById('eventManagerFilter');
            Array.from(eventManagers).sort().forEach(manager => {
                const option = document.createElement('option');
                option.value = manager;
                option.textContent = manager;
                managerSelect.appendChild(option);
            });
        }



        // Erweiterte Filter anwenden
        function applyFilters() {
            const regionFilter = document.getElementById('regionFilter').value;
            const countryFilter = document.getElementById('countryFilter').value;
            const eventManagerFilter = document.getElementById('eventManagerFilter').value;
            const minEvents = parseInt(document.getElementById('minEvents').value) || 1;
            const minDays = parseInt(document.getElementById('minDays').value) || 1;
            const sortBy = document.getElementById('sortBy').value;

            let filtered = analysisResults.filter(location => {
                // Region-Filter
                if (regionFilter !== 'all' && location.region !== regionFilter) {
                    return false;
                }

                // Land-Filter
                if (countryFilter !== 'all' && location.country !== countryFilter) {
                    return false;
                }

                // Event Manager-Filter
                if (eventManagerFilter !== 'all') {
                    const hasManager = location.events.some(event => event.event_manager === eventManagerFilter);
                    if (!hasManager) return false;
                }

                // Mindestanzahl Events
                if (location.events.length < minEvents) {
                    return false;
                }

                // Mindestanzahl Tage
                if (location.totalDays < minDays) {
                    return false;
                }

                return true;
            });

            // Sortierung
            filtered.sort((a, b) => {
                switch (sortBy) {
                    case 'events':
                        return b.events.length - a.events.length;
                    case 'days':
                        return b.totalDays - a.totalDays;
                    case 'saving':
                        return b.maxDailySavings - a.maxDailySavings;
                    case 'location':
                        return a.location.localeCompare(b.location);
                    default:
                        return b.totalDays - a.totalDays;
                }
            });

            // Gefilterte Ergebnisse setzen und erste Seite anzeigen
            filteredResults = filtered;
            currentPage = 1;
            displayFilteredResults(filtered);
            updatePagination();
            updateActiveFiltersDisplay();
        }

        // Filter zur√ºcksetzen
        function resetFilters() {
            document.getElementById('regionFilter').value = 'all';
            document.getElementById('countryFilter').value = 'all';
            document.getElementById('eventManagerFilter').value = 'all';
            document.getElementById('minEvents').value = '1';
            document.getElementById('minDays').value = '1';
            document.getElementById('sortBy').value = 'days';

            filteredResults = [...analysisResults];
            currentPage = 1;
            displayFilteredResults(filteredResults);
            updatePagination();
            updateActiveFiltersDisplay();
        }

        // Seite wechseln
        function changePage(direction) {
            const totalPages = Math.ceil(filteredResults.length / itemsPerPage);
            currentPage += direction;

            if (currentPage < 1) currentPage = 1;
            if (currentPage > totalPages) currentPage = totalPages;

            displayFilteredResults(filteredResults);
            updatePagination();
        }

        // Pagination aktualisieren
        function updatePagination() {
            const totalPages = Math.ceil(filteredResults.length / itemsPerPage);
            const pageInfo = document.getElementById('pageInfo');
            const paginationInfo = document.getElementById('paginationInfo');
            const prevBtn = document.getElementById('prevPage');
            const nextBtn = document.getElementById('nextPage');

            if (totalPages > 1) {
                pageInfo.textContent = `Seite ${currentPage} von ${totalPages}`;
                paginationInfo.style.display = 'flex';

                prevBtn.disabled = currentPage === 1;
                nextBtn.disabled = currentPage === totalPages;
            } else {
                paginationInfo.style.display = 'none';
            }
        }

        // Aktive Filter anzeigen
        function updateActiveFiltersDisplay() {
            const activeFiltersDiv = document.getElementById('activeFilters');
            const filters = [];

            const regionFilter = document.getElementById('regionFilter').value;
            const countryFilter = document.getElementById('countryFilter').value;
            const eventManagerFilter = document.getElementById('eventManagerFilter').value;
            const minEvents = parseInt(document.getElementById('minEvents').value) || 1;
            const minDays = parseInt(document.getElementById('minDays').value) || 1;

            if (regionFilter !== 'all') filters.push(`Region: ${regionFilter}`);
            if (countryFilter !== 'all') filters.push(`Land: ${countryFilter}`);
            if (eventManagerFilter !== 'all') filters.push(`Manager: ${eventManagerFilter}`);
            if (minEvents > 1) filters.push(`Min. Events: ${minEvents}`);
            if (minDays > 1) filters.push(`Min. Tage: ${minDays}`);

            if (filters.length > 0) {
                activeFiltersDiv.innerHTML = `
                    <h4>Aktive Filter:</h4>
                    <ul>${filters.map(f => `<li>${f}</li>`).join('')}</ul>
                `;
            } else {
                activeFiltersDiv.innerHTML = '<p>Keine Filter aktiv</p>';
            }
        }

        // Hilfsfunktion f√ºr Datumsformat-Konvertierung
        function convertToHtmlDateFormat(dateString) {
            if (!dateString) return '';

            // Format: "DD.MM.YYYY" -> "YYYY-MM-DD"
            const parts = dateString.split('.');
            if (parts.length === 3) {
                const day = parts[0].padStart(2, '0');
                const month = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }

            // Fallback: versuche andere g√§ngige Formate
            if (dateString.includes('/')) {
                const parts = dateString.split('/');
                if (parts.length === 3) {
                    // Format: "MM/DD/YYYY"
                    const month = parts[0].padStart(2, '0');
                    const day = parts[1].padStart(2, '0');
                    const year = parts[2];
                    return `${year}-${month}-${day}`;
                }
            }

            // Wenn nichts passt, gib das Original zur√ºck
            return dateString;
        }

        // Hilfsfunktion f√ºr R√ºckkonvertierung ins JSON-Format
        function convertFromHtmlDateFormat(dateString) {
            if (!dateString) return '';

            // Format: "YYYY-MM-DD" -> "DD.MM.YYYY"
            const parts = dateString.split('-');
            if (parts.length === 3) {
                const year = parts[0];
                const month = parts[1];
                const day = parts[2];
                return `${day}.${month}.${year}`;
            }

            // Wenn nichts passt, gib das Original zur√ºck
            return dateString;
        }

        // Veranstaltung Edit Modal Funktionen
        function openEditEventModal(locationIndex, eventIndex) {
            currentEditingLocationIndex = locationIndex;
            currentEditingEventIndex = eventIndex;

            const location = filteredResults[locationIndex];
            const event = location.events[eventIndex];

            // Formular mit aktuellen Daten f√ºllen
            document.getElementById('editEventName').value = event.name || '';
            document.getElementById('editEventStartDate').value = convertToHtmlDateFormat(event.start_date) || '';
            document.getElementById('editEventEndDate').value = convertToHtmlDateFormat(event.end_date) || '';
            document.getElementById('editEventDiscipline').value = event.discipline || '';
            document.getElementById('editEventManager').value = event.event_manager || '';
            document.getElementById('editEventKiSuitable').checked = event.kiSuitable || false;
            document.getElementById('editEventNotes').value = event.notes || '';

            // Modal anzeigen
            document.getElementById('editEventModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeEditEventModal() {
            document.getElementById('editEventModal').style.display = 'none';
            document.body.style.overflow = 'auto';
            currentEditingLocationIndex = null;
            currentEditingEventIndex = null;
        }

        function saveEditedEvent() {
            if (currentEditingLocationIndex === null || currentEditingEventIndex === null) {
                alert('Fehler: Keine Veranstaltung ausgew√§hlt');
                return;
            }

            const form = document.getElementById('editEventForm');
            if (!form.checkValidity()) {
                form.reportValidity();
                return;
            }

            // Neue Daten aus dem Formular sammeln und Datumsformate konvertieren
            const updatedEvent = {
                name: document.getElementById('editEventName').value,
                start_date: convertFromHtmlDateFormat(document.getElementById('editEventStartDate').value),
                end_date: convertFromHtmlDateFormat(document.getElementById('editEventEndDate').value),
                discipline: document.getElementById('editEventDiscipline').value,
                event_manager: document.getElementById('editEventManager').value,
                kiSuitable: document.getElementById('editEventKiSuitable').checked,
                notes: document.getElementById('editEventNotes').value
            };

            // Veranstaltung aktualisieren
            filteredResults[currentEditingLocationIndex].events[currentEditingEventIndex] = updatedEvent;

            // √Ñnderungen in JSON-Datei speichern
            saveEventsToJsonFile();

            // Daten neu berechnen und anzeigen
            analyzeLocations(filteredResults[currentEditingLocationIndex]);
            displayAnalysisResults();

            // Modal schlie√üen
            closeEditEventModal();

            alert('Veranstaltung erfolgreich aktualisiert und gespeichert!');

            // Zeige Storage-Info Modal nach erfolgreichem Speichern
            setTimeout(() => showStorageInfoModal(), 500);
        }

        function deleteEvent() {
            if (currentEditingLocationIndex === null || currentEditingEventIndex === null) {
                alert('Fehler: Keine Veranstaltung ausgew√§hlt');
                return;
            }

            if (!confirm('Sind Sie sicher, dass Sie diese Veranstaltung l√∂schen m√∂chten?')) {
                return;
            }

            // Veranstaltung entfernen
            filteredResults[currentEditingLocationIndex].events.splice(currentEditingEventIndex, 1);

            // Daten neu berechnen und anzeigen
            if (filteredResults[currentEditingLocationIndex].events.length === 0) {
                // Standort entfernen wenn keine Veranstaltungen mehr vorhanden
                filteredResults.splice(currentEditingLocationIndex, 1);
            } else {
                analyzeLocations(filteredResults[currentEditingLocationIndex]);
            }

            displayAnalysisResults();

            // Modal schlie√üen
            closeEditEventModal();

            alert('Veranstaltung erfolgreich gel√∂scht!');
        }

        // Storage Info Modal Funktionen
        function showStorageInfoModal() {
            document.getElementById('storageInfoModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeStorageInfoModal() {
            document.getElementById('storageInfoModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Modal schlie√üen beim Klick au√üerhalb
        window.onclick = function(event) {
            const editEventModal = document.getElementById('editEventModal');
            const storageInfoModal = document.getElementById('storageInfoModal');
            const downloadInfoModal = document.getElementById('downloadInfoModal');

            if (event.target === editEventModal) {
                closeEditEventModal();
            }
            if (event.target === storageInfoModal) {
                closeStorageInfoModal();
            }
            if (event.target === downloadInfoModal) {
                closeDownloadInfoModal();
            }
        }

        // Daten in JSON-Datei speichern (mehrere Methoden)
        async function saveEventsToJsonFile() {
            try {
                // Konvertiere filteredResults zur√ºck in das urspr√ºngliche Format
                const eventsToSave = [];

                filteredResults.forEach(location => {
                    location.events.forEach(event => {
                        eventsToSave.push({
                            id: event.id,
                            name: event.name,
                            location: location.location,
                            country: location.country,
                            start_date: event.start_date,
                            end_date: event.end_date,
                            discipline: event.discipline,
                            event_manager: event.event_manager,
                            kiSuitable: event.kiSuitable || false,
                            notes: event.notes || ''
                        });
                    });
                });

                console.log('üíæ Versuche Events in JSON-Datei zu speichern...');

                // Z√§hle ge√§nderte Events
                const changedEvents = eventsToSave.filter(event => event.kiSuitable || event.notes).length;
                console.log('üìù Ge√§nderte Events:', changedEvents);

                // Versuche verschiedene Speichermethoden
                let saved = false;

                // Methode 1: PHP-Server (falls verf√ºgbar)
                if (!saved) {
                    saved = await saveViaPHP(eventsToSave);
                }

                // Methode 2: File System Access API (moderne Browser)
                if (!saved) {
                    saved = await saveViaFileSystemAPI(eventsToSave);
                }

                // Methode 3: Fallback - Download der ge√§nderten JSON
                if (!saved) {
                    saveViaDownload(eventsToSave);
                }

            } catch (error) {
                console.error('‚ùå Fehler beim Speichern:', error);
                // Fallback: localStorage
                saveToLocalStorageFallback();
            }
        }

        // PHP-basierte Speicherung
        async function saveViaPHP(events) {
            try {
                const response = await fetch('save_events.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ events: events })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('‚úÖ Events erfolgreich √ºber PHP gespeichert!');
                        console.log('üîÑ Die events.json wurde automatisch aktualisiert');
                        return true;
                    } else {
                        console.log('‚ùå PHP-Speicherung fehlgeschlagen:', result.message);
                    }
                } else {
                    console.log('‚ùå HTTP-Fehler bei PHP-Speicherung:', response.status);
                }
            } catch (error) {
                console.log('‚ö†Ô∏è PHP-Server nicht verf√ºgbar oder save_events.php nicht gefunden');
                console.log('üí° Fallback: Verwenden Sie den Download oder File System Access');
                console.log('üí° Tipp: Erstellen Sie eine save_events.php Datei f√ºr automatische Speicherung');
            }
            return false;
        }

        // File System Access API (Chrome/Edge)
        async function saveViaFileSystemAPI(events) {
            try {
                // Pr√ºfe ob API verf√ºgbar
                if (!('showSaveFilePicker' in window)) {
                    return false;
                }

                console.log('üìÇ File System Access API verf√ºgbar');

                const handle = await window.showSaveFilePicker({
                    suggestedName: 'events.json',
                    types: [{
                        description: 'JSON Datei',
                        accept: { 'application/json': ['.json'] }
                    }]
                });

                const writable = await handle.createWritable();
                const jsonContent = JSON.stringify({ events: events }, null, 2);

                await writable.write(jsonContent);
                await writable.close();

                console.log('‚úÖ Events erfolgreich √ºber File System API gespeichert!');
                return true;

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.log('‚ö†Ô∏è File System API nicht verwendet oder abgebrochen');
                }
            }
            return false;
        }

        // Download als Fallback
        function saveViaDownload(events) {
            try {
                const jsonContent = JSON.stringify({ events: events }, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'events_updated.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('üì• Ge√§nderte events.json zum Download bereit!');
                console.log('üí° Ersetzen Sie die urspr√ºngliche events.json mit der heruntergeladenen Datei.');
                console.log('üí° Oder verwenden Sie einen PHP-Server f√ºr automatische Speicherung.');

                // Zeige Info-Modal
                setTimeout(() => showDownloadInfoModal(), 1000);

            } catch (error) {
                console.error('‚ùå Download fehlgeschlagen:', error);
            }
        }

        // Fallback: localStorage
        function saveToLocalStorageFallback() {
            try {
                const eventsToSave = [];
                filteredResults.forEach(location => {
                    location.events.forEach(event => {
                        eventsToSave.push({
                            id: event.id,
                            name: event.name,
                            location: location.location,
                            country: location.country,
                            start_date: event.start_date,
                            end_date: event.end_date,
                            discipline: event.discipline,
                            event_manager: event.event_manager,
                            kiSuitable: event.kiSuitable || false,
                            notes: event.notes || ''
                        });
                    });
                });

                localStorage.setItem('editedEvents', JSON.stringify(eventsToSave));
                console.log('üíæ Events in localStorage gespeichert (Fallback)');

            } catch (error) {
                console.error('‚ùå localStorage Fallback fehlgeschlagen:', error);
            }
        }

        // Gespeicherte Events aus localStorage laden
        function loadEventsFromLocalStorage() {
            try {
                const savedEvents = localStorage.getItem('editedEvents');
                if (savedEvents) {
                    const parsedEvents = JSON.parse(savedEvents);
                    console.log('üìÇ Gespeicherte Events geladen:', parsedEvents.length, 'Events');
                    return parsedEvents;
                }
            } catch (error) {
                console.error('‚ùå Fehler beim Laden:', error);
            }
            return null;
        }

        // Download Info Modal Funktionen
        function showDownloadInfoModal() {
            document.getElementById('downloadInfoModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeDownloadInfoModal() {
            document.getElementById('downloadInfoModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Export-Funktion f√ºr Entwickler (Konsole)
        function exportEditedEvents() {
            const savedEvents = localStorage.getItem('editedEvents');
            if (savedEvents) {
                const events = JSON.parse(savedEvents);
                const jsonString = JSON.stringify({ events }, null, 2);

                // Kopiere in Zwischenablage (falls m√∂glich)
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(jsonString).then(() => {
                        console.log('‚úÖ JSON kopiert in Zwischenablage!');
                        console.log('üí° F√ºge diese Daten in events.json ein, um sie dauerhaft zu speichern.');
                    });
                }

                console.log('üìÑ Export-JSON (kopiere f√ºr events.json):');
                console.log(jsonString);

                return jsonString;
            } else {
                console.log('‚ùå Keine gespeicherten Events gefunden');
                return null;
            }
        }

        // Funktion global verf√ºgbar machen
        window.exportEditedEvents = exportEditedEvents;

        // Funktion zum L√∂schen gespeicherter Events
        function clearEditedEvents() {
            localStorage.removeItem('editedEvents');
            console.log('üóëÔ∏è Gespeicherte Events gel√∂scht - Seite neu laden f√ºr Original-Daten');
            location.reload();
        }

        // Funktion global verf√ºgbar machen
        window.clearEditedEvents = clearEditedEvents;

        // Seite initialisieren
        document.addEventListener('DOMContentLoaded', loadAndAnalyzeEvents);
    </script>

    <!-- PHP-Server Info -->
    <div style="display: none;" id="php-server-info">
        <div style="position: fixed; bottom: 10px; right: 10px; background: #f8f9fa; border: 1px solid #e0e0e0; padding: 1rem; border-radius: 8px; max-width: 300px; font-size: 0.8rem; z-index: 1000;">
            <strong>üí° PHP-Server f√ºr automatische Speicherung:</strong><br>
            F√ºr direkte JSON-Speicherung erstellen Sie eine <code>save_events.php</code> Datei.<br>
            <button onclick="this.parentElement.style.display='none'" style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.7rem;">Schlie√üen</button>
        </div>
    </div>

    <script>
        // Zeige PHP-Info nach einiger Zeit, wenn kein PHP verf√ºgbar ist
        setTimeout(() => {
            if (!document.querySelector('.php-info-shown')) {
                document.getElementById('php-server-info').style.display = 'block';
                document.querySelector('.php-info-shown')?.classList.add('php-info-shown');
            }
        }, 5000);

        // Markiere als PHP-Info gezeigt
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                document.body.classList.add('php-info-shown');
            }, 100);
        });
    </script>
</body>
</html>
